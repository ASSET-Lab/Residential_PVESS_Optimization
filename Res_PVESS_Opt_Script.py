# -*- coding: utf-8 -*-
"""FinalPythonScript

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_Qg60HLGaere4IYt2sigzJQFp1xIJbUY
"""

import pandas as pd
import numpy as np
import pyomo.environ as pyo
import json

# the optimization code is now a FUNCTION that will be called in the multi processing code

def optimizationCode(demand_file, generation_file, rate_file, timeSpan,
                    batteryCapacity, chargeEfficiency, dischargeEfficiency,
                    chargeLimit, dischargeLimit):

  print(demand_file)
  # UPDATE -- make demand generation and rate file into dataFrame IN the function
  try:
      demandDF = pd.read_csv(demand_file, usecols = [0, 1], nrows = timeSpan)
  except Exception as e:
      print(f"Demand File Error: {e}")

  try:
      generationDF = pd.read_csv(generation_file, usecols = [1], nrows = timeSpan)
  except Exception as e:
      print(f"Generation File Error: {e}")

  try:
      rateDF = pd.read_csv(rate_file, usecols = ['price'], nrows = timeSpan)
  except Exception as e:
      print(f"Rate File Error: {e}")

  mergedDF = pd.concat([demandDF, generationDF, rateDF], axis = 1)
  mergedDF.columns = ['Hour of Year', 'Energy Demand kWh', 'Solar Generation kWh', 'Price']
  mergedDF['Hour of Year'] = range(1, len(mergedDF) + 1)

  # array containing the rate of pulling from the grid every hour of the year
  demand = demandDF['Demand_kWh'].tolist()
  generation = generationDF['SolarGen_kWh'].tolist()
  gridRate = rateDF['price'].tolist()

  # initialize model
  # we'll build the model ONCE bc we want to optimize over the ENTIRE timeSpan
  model = pyo.ConcreteModel()
  # use to index constraint in the Pyomo optimization model
  model.I = pyo.RangeSet(0, timeSpan - 1)
  model.ISpecial = pyo.RangeSet(0, timeSpan)

  # define decision variable
  model.c = pyo.Var(model.I, within = pyo.NonNegativeReals) # charge
  model.p = pyo.Var(model.I, within = pyo.NonNegativeReals) # discharge
  model.x = pyo.Var(model.I, within = pyo.NonNegativeReals) # amnt pulled from grid
  model.currentCharge = pyo.Var(model.ISpecial, within = pyo.NonNegativeReals) # battery charge in each hour
  # creating a slack variable for "wasted" solar allowing the model to spill unused solar
  model.spill = pyo.Var(model.I, within = pyo.NonNegativeReals)

  # define objective function
  # we want to minimize cost over the ENTIRE timeSpan so we use SUM
  model.obj = pyo.Objective(expr = sum(gridRate[i] * model.x[i] for i in model.I), sense = pyo.minimize)

  # define constraint

  # Constraint 1
  def gridPullConstraint(model, i):
  # incorporating the waste decision variable in the objective function
  # to allow the model to dispell left over generated energy that can't be stored in the battery
  # essentially if you can't store or consume all solar generation ... SPILL THE REST
  # - dischargeEfficiency * amnt pulled from battery bc you want to subtract from demand the actual amnt that you'll get
  # - no chargeEfficiency * amnt inputted in battery bc you want the amnt that you attempt to store before the efficiency has taken effect
    return demand[i] - generation[i] + model.c[i] - dischargeEfficiency * model.p[i] + model.spill[i] == model.x[i]
  model.del_component('constraint1') # to ensure that the constraint isn't overwritten
  model.constraint1 = pyo.Constraint(model.I, rule = gridPullConstraint)

  # Constraint 2 A
  def initialChargeConstraint(model):
    # battery charge = 0 at the beginning of the timeSpan
    return model.currentCharge[0] == 0
  model.del_component('initial_charge') # to ensure that the constraint isn't overwritten
  model.initial_charge = pyo.Constraint(rule = initialChargeConstraint)

  # Constraint 2 B
  def batteryChargeConstraint(model, i):
    # chargeEfficiency * amnt inputted in battery bc you want to capture the actual amnt that will make it into the battery
    # no dischargeEfficiency * amnt pulled from battery
    # bc you want to subtract what you initially took from the battery prior to the efficiency defect
    return model.currentCharge[i + 1] == model.currentCharge[i] + chargeEfficiency * model.c[i] - model.p[i]
  model.del_component('battery_dynamic') # to ensure that the constraint isn't overwritten
  model.battery_dynamic = pyo.Constraint(model.I, rule = batteryChargeConstraint)

  # Constraint 3
  def batteryCapacityConstraint(model, i):
    return model.currentCharge[i] <= batteryCapacity
  model.del_component('constraint3') # to ensure that the constraint isn't overwritten
  model.constraint3 = pyo.Constraint(model.ISpecial, rule = batteryCapacityConstraint)

  # Constraint 4
  def chargeLimitConstraint(model, i):
    return model.c[i] <= chargeLimit
  model.del_component('constraint4') # to ensure that the constraint isn't overwritten
  model.constraint4 = pyo.Constraint(model.I, rule = chargeLimitConstraint)

  # Constraint 5
  def dischargeLimitConstraint(model, i):
    return model.p[i] <= dischargeLimit
  model.del_component('constraint5') # to ensure that the constraint isn't overwritten
  model.constraint5 = pyo.Constraint(model.I, rule = dischargeLimitConstraint)

  # select solver and solve
  solver = pyo.SolverFactory('cbc')
  solver.solve(model, tee = False)

  # store hourly data respectively
  inputBattery = np.array([pyo.value(model.c[i]) for i in model.I])
  dischargeBattery = np.array([pyo.value(model.p[i]) for i in model.I])
  currentCharge = np.array([pyo.value(model.currentCharge[i]) for i in model.I])
  spilledEnergy = np.array([pyo.value(model.spill[i]) for i in model.I])
  gridPull = np.array([pyo.value(model.x[i]) for i in model.I])
  gridPurchase = gridPull * np.array([gridRate[i] for i in model.I])
  cumulativeGridSpending = np.cumsum(gridPurchase)

  # input stored data into the Data Frame
  mergedDF['Battery Input kWh'] = inputBattery
  mergedDF['Battery Dispatch kWh'] = dischargeBattery
  mergedDF['Battery Charge kWh'] = currentCharge
  mergedDF['Energy Spilled kWh'] = spilledEnergy
  mergedDF['Grid Dispatch kWh'] = gridPull
  mergedDF['Hourly Grid Spending $'] = gridPurchase
  mergedDF['Cumulative Grid Spending $'] = cumulativeGridSpending

  return mergedDF # returning the final mergedDF with all information

from joblib import Parallel, delayed # leveraging multi processing core for speed
# UPDATE -- json file read in containing different case parameter
with open('case_params.json', 'r') as f:
    case_params = json.load(f)

def runCase(case):

    # calling optimizationCode function within the new runCase function
    mergedDF = optimizationCode(
        case["demand_file"],
        case["generation_file"],
        case["rate_file"],
        case["timeSpan"],
        case["batteryCapacity"],
        case["chargeEfficiency"],
        case["dischargeEfficiency"],
        case["chargeLimit"],
        case["dischargeLimit"]
    )

    # outputting CSV as final product
    mergedDF.to_csv(f'gridPullCase{case["case_id"]}.csv', columns = ["Hour of Year", "Grid Dispatch kWh"], index = False)
    mergedDF.to_csv(f'fullDataFrameCase{case["case_id"]}.csv', index = False)

    return mergedDF

result = Parallel(n_jobs = -1)(delayed(runCase)(case) for case in case_params) # allowing function runCase to run once for each case
# result will contain the output from each run